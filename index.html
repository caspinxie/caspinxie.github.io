<!DOCTYPE html>
<html>
<head>
    <title>Florr.io Clone</title>
    <style>
        canvas { border: 2px solid #333; }
        body { margin: 0; overflow: hidden; background: #87CEEB; }
        #ui { position: fixed; top: 10px; left: 10px; color: white; font-family: Arial; }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>
    <div id="ui"></div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const UI = document.getElementById('ui');
    
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;

        // Game state
        const state = {
            player: {
                x: canvas.width/2,
                y: canvas.height/2,
                radius: 25,
                speed: 5,
                health: 100,
                maxHealth: 100,
                petals: [],
                equipped: [],
                lastShot: 0,
                shotCooldown: 200
            },
            projectiles: [],
            petals: [],
            enemies: [],
            lastEnemySpawn: 0,
            enemySpawnCooldown: 2000
        };

        // Petal types
        const PETAL_TYPES = {
            rose: { color: '#FF69B4', damage: -15, cooldown: 1000 }, // Healing
            cactus: { color: '#228B22', damage: 20, cooldown: 500 },
            stinger: { color: '#FFD700', damage: 30, cooldown: 800 }
        };

        // Input handling
        const keys = {
            ArrowUp: false, ArrowDown: false,
            ArrowLeft: false, ArrowRight: false,
            Space: false
        };

        // Event listeners
        window.addEventListener('keydown', (e) => keys[e.key] = true);
        window.addEventListener('keyup', (e) => keys[e.key] = false);
        window.addEventListener('resize', () => {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        });

        // Spawn initial petals
        function spawnPetals() {
            for(let i = 0; i < 15; i++) {
                state.petals.push({
                    x: Math.random() * canvas.width,
                    y: Math.random() * canvas.height,
                    type: Object.keys(PETAL_TYPES)[Math.floor(Math.random()*3)]
                });
            }
        }

        // Spawn enemies
        function spawnEnemy() {
            state.enemies.push({
                x: Math.random() < 0.5 ? -50 : canvas.width + 50,
                y: Math.random() * canvas.height,
                radius: 30,
                health: 50,
                speed: 2
            });
        }

        // Combat system
        function shoot(petalType) {
            const now = Date.now();
            if(now - state.player.lastShot > PETAL_TYPES[petalType].cooldown) {
                const angle = Math.atan2(
                    state.player.y - canvas.height/2,
                    state.player.x - canvas.width/2
                );
                
                state.projectiles.push({
                    x: state.player.x,
                    y: state.player.y,
                    radius: 10,
                    damage: PETAL_TYPES[petalType].damage,
                    color: PETAL_TYPES[petalType].color,
                    dx: -Math.cos(angle) * 8,
                    dy: -Math.sin(angle) * 8
                });
                
                state.player.lastShot = now;
            }
        }

        // Update loop
        function update() {
            // Player movement
            if(keys.ArrowUp) state.player.y -= state.player.speed;
            if(keys.ArrowDown) state.player.y += state.player.speed;
            if(keys.ArrowLeft) state.player.x -= state.player.speed;
            if(keys.ArrowRight) state.player.x += state.player.speed;

            // Shooting
            if(keys.Space && state.player.equipped.length > 0) {
                shoot(state.player.equipped[0].type);
            }

            // Collect petals
            state.petals = state.petals.filter(petal => {
                const dx = state.player.x - petal.x;
                const dy = state.player.y - petal.y;
                const distance = Math.sqrt(dx*dx + dy*dy);
                
                if(distance < state.player.radius + 15) {
                    state.player.equipped.push({ 
                        type: petal.type,
                        ...PETAL_TYPES[petal.type]
                    });
                    return false;
                }
                return true;
            });

            // Update projectiles
            state.projectiles.forEach(projectile => {
                projectile.x += projectile.dx;
                projectile.y += projectile.dy;
            });

            // Update enemies
            const now = Date.now();
            if(now - state.lastEnemySpawn > state.enemySpawnCooldown) {
                spawnEnemy();
                state.lastEnemySpawn = now;
            }

            state.enemies.forEach(enemy => {
                // Move towards player
                const angle = Math.atan2(
                    state.player.y - enemy.y,
                    state.player.x - enemy.x
                );
                enemy.x += Math.cos(angle) * enemy.speed;
                enemy.y += Math.sin(angle) * enemy.speed;

                // Collision with player
                const dx = state.player.x - enemy.x;
                const dy = state.player.y - enemy.y;
                const distance = Math.sqrt(dx*dx + dy*dy);
                
                if(distance < state.player.radius + enemy.radius) {
                    state.player.health -= 1;
                }
            });

            // Collision detection
            state.projectiles = state.projectiles.filter(projectile => {
                state.enemies.forEach(enemy => {
                    const dx = projectile.x - enemy.x;
                    const dy = projectile.y - enemy.y;
                    const distance = Math.sqrt(dx*dx + dy*dy);
                    
                    if(distance < projectile.radius + enemy.radius) {
                        enemy.health += projectile.damage;
                        if(enemy.health <= 0) {
                            state.enemies.splice(state.enemies.indexOf(enemy), 1);
                        }
                    }
                });
                return projectile.x > -50 && projectile.x < canvas.width + 50 &&
                       projectile.y > -50 && projectile.y < canvas.height + 50;
            });
        }

        // Render
        function draw() {
            ctx.fillStyle = '#87CEEB';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Draw player
            ctx.fillStyle = '#FFFFFF';
            ctx.beginPath();
            ctx.arc(state.player.x, state.player.y, state.player.radius, 0, Math.PI*2);
            ctx.fill();

            // Draw equipped petals
            state.player.equipped.forEach((petal, i) => {
                ctx.fillStyle = petal.color;
                ctx.beginPath();
                ctx.arc(
                    state.player.x + Math.cos((i * Math.PI/2)) * 35,
                    state.player.y + Math.sin((i * Math.PI/2)) * 35,
                    12, 0, Math.PI*2
                );
                ctx.fill();
            });

            // Draw projectiles
            state.projectiles.forEach(projectile => {
                ctx.fillStyle = projectile.color;
                ctx.beginPath();
                ctx.arc(projectile.x, projectile.y, projectile.radius, 0, Math.PI*2);
                ctx.fill();
            });

            // Draw petals
            state.petals.forEach(petal => {
                ctx.fillStyle = PETAL_TYPES[petal.type].color;
                ctx.beginPath();
                ctx.arc(petal.x, petal.y, 15, 0, Math.PI*2);
                ctx.fill();
            });

            // Draw enemies
            state.enemies.forEach(enemy => {
                ctx.fillStyle = '#FF4444';
                ctx.beginPath();
                ctx.arc(enemy.x, enemy.y, enemy.radius, 0, Math.PI*2);
                ctx.fill();
            });

            // UI
            UI.innerHTML = `
                Health: ${Math.round(state.player.health)}<br>
                Petals: ${state.player.equipped.length}<br>
                ${state.player.equipped.map(p => p.type).join(', ')}
            `;
        }

        // Game loop
        function gameLoop() {
            update();
            draw();
            requestAnimationFrame(gameLoop);
        }

        // Start game
        spawnPetals();
        gameLoop();
    </script>
</body>
</htmlstate.lastEnemySpawn = now;
            }

            state.enemies.forEach(enemy => {
                // Move towards player
                const angle = Math.atan2(
                    state.player.y - enemy.y,
                    state.player.x - enemy.x
                );
                enemy.x += Math.cos(angle) * enemy.speed;
                enemy.y += Math.sin(angle) * enemy.speed;

                // Collision with player
                const dx = state.player.x - enemy.x;
                const dy = state.player.y - enemy.y;
                const distance = Math.sqrt(dx*dx + dy*dy);
                
                if(distance < state.player.radius + enemy.radius) {
                    state.player.health -= 1;
                }
            });

            // Collision detection
            state.projectiles = state.projectiles.filter(projectile => {
                state.enemies.forEach(enemy => {
                    const dx = projectile.x - enemy.x;
                    const dy = projectile.y - enemy.y;
                    const distance = Math.sqrt(dx*dx + dy*dy);
                    
                    if(distance < projectile.radius + enemy.radius) {
                        enemy.health += projectile.damage;
                        if(enemy.health <= 0) {
                            state.enemies.splice(state.enemies.indexOf(enemy), 1);
                        }
                    }
                });
                return projectile.x > -50 && projectile.x < canvas.width + 50 &&
                       projectile.y > -50 && projectile.y < canvas.height + 50;
            });
        }

        // Render
        function draw() {
            ctx.fillStyle = '#87CEEB';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Draw player
            ctx.fillStyle = '#FFFFFF';
            ctx.beginPath();
            ctx.arc(state.player.x, state.player.y, state.player.radius, 0, Math.PI*2);
            ctx.fill();

            // Draw equipped petals
            state.player.equipped.forEach((petal, i) => {
                ctx.fillStyle = petal.color;
                ctx.beginPath();
                ctx.arc(
                    state.player.x + Math.cos((i * Math.PI/2)) * 35,
                    state.player.y + Math.sin((i * Math.PI/2)) * 35,
                    12, 0, Math.PI*2
                );
                ctx.fill();
            });

            // Draw projectiles
            state.projectiles.forEach(projectile => {
                ctx.fillStyle = projectile.color;
                ctx.beginPath();
                ctx.arc(projectile.x, projectile.y, projectile.radius, 0, Math.PI*2);
                ctx.fill();
            });

            // Draw petals
            state.petals.forEach(petal => {
                ctx.fillStyle = PETAL_TYPES[petal.type].color;
                ctx.beginPath();
                ctx.arc(petal.x, petal.y, 15, 0, Math.PI*2);
                ctx.fill();
            });

            // Draw enemies
            state.enemies.forEach(enemy => {
                ctx.fillStyle = '#FF4444';
                ctx.beginPath();
                ctx.arc(enemy.x, enemy.y, enemy.radius, 0, Math.PI*2);
                ctx.fill();
            });

            // UI
            UI.innerHTML = `
                Health: ${Math.round(state.player.health)}<br>
                Petals: ${state.player.equipped.length}<br>
                ${state.player.equipped.map(p => p.type).join(', ')}
            `;
        }

        // Game loop
        function gameLoop() {
            update();
            draw();
            requestAnimationFrame(gameLoop);
        }

        // Start game
        spawnPetals();
        gameLoop();
    </script>
</body>
</htmlstate.lastEnemySpawn = now;
            }

            state.enemies.forEach(enemy => {
                // Move towards player
                const angle = Math.atan2(
                    state.player.y - enemy.y,
                    state.player.x - enemy.x
                );
                enemy.x += Math.cos(angle) * enemy.speed;
                enemy.y += Math.sin(angle) * enemy.speed;

                // Collision with player
                const dx = state.player.x - enemy.x;
                const dy = state.player.y - enemy.y;
                const distance = Math.sqrt(dx*dx + dy*dy);
                
                if(distance < state.player.radius + enemy.radius) {
                    state.player.health -= 1;
                }
            });

            // Collision detection
            state.projectiles = state.projectiles.filter(projectile => {
                state.enemies.forEach(enemy => {
                    const dx = projectile.x - enemy.x;
                    const dy = projectile.y - enemy.y;
                    const distance = Math.sqrt(dx*dx + dy*dy);
                    
                    if(distance < projectile.radius + enemy.radius) {
                        enemy.health += projectile.damage;
                        if(enemy.health <= 0) {
                            state.enemies.splice(state.enemies.indexOf(enemy), 1);
                        }
                    }
                });
                return projectile.x > -50 && projectile.x < canvas.width + 50 &&
                       projectile.y > -50 && projectile.y < canvas.height + 50;
            });
        }

        // Render
        function draw() {
            ctx.fillStyle = '#87CEEB';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Draw player
            ctx.fillStyle = '#FFFFFF';
            ctx.beginPath();
            ctx.arc(state.player.x, state.player.y, state.player.radius, 0, Math.PI*2);
            ctx.fill();

            // Draw equipped petals
            state.player.equipped.forEach((petal, i) => {
                ctx.fillStyle = petal.color;
                ctx.beginPath();
                ctx.arc(
                    state.player.x + Math.cos((i * Math.PI/2)) * 35,
                    state.player.y + Math.sin((i * Math.PI/2)) * 35,
                    12, 0, Math.PI*2
                );
                ctx.fill();
            });

            // Draw projectiles
            state.projectiles.forEach(projectile => {
                ctx.fillStyle = projectile.color;
                ctx.beginPath();
                ctx.arc(projectile.x, projectile.y, projectile.radius, 0, Math.PI*2);
                ctx.fill();
            });

            // Draw petals
            state.petals.forEach(petal => {
                ctx.fillStyle = PETAL_TYPES[petal.type].color;
                ctx.beginPath();
                ctx.arc(petal.x, petal.y, 15, 0, Math.PI*2);
                ctx.fill();
            });

            // Draw enemies
            state.enemies.forEach(enemy => {
                ctx.fillStyle = '#FF4444';
                ctx.beginPath();
                ctx.arc(enemy.x, enemy.y, enemy.radius, 0, Math.PI*2);
                ctx.fill();
            });

            // UI
            UI.innerHTML = `
                Health: ${Math.round(state.player.health)}<br>
                Petals: ${state.player.equipped.length}<br>
                ${state.player.equipped.map(p => p.type).join(', ')}
            `;
        }

        // Game loop
        function gameLoop() {
            update();
            draw();
            requestAnimationFrame(gameLoop);
        }

        // Start game
        spawnPetals();
        gameLoop();
    </script>
</body>
</htmlstate.lastEnemySpawn = now;
            }

            state.enemies.forEach(enemy => {
                // Move towards player
                const angle = Math.atan2(
                    state.player.y - enemy.y,
                    state.player.x - enemy.x
                );
                enemy.x += Math.cos(angle) * enemy.speed;
                enemy.y += Math.sin(angle) * enemy.speed;

                // Collision with player
                const dx = state.player.x - enemy.x;
                const dy = state.player.y - enemy.y;
                const distance = Math.sqrt(dx*dx + dy*dy);
                
                if(distance < state.player.radius + enemy.radius) {
                    state.player.health -= 1;
                }
            });

            // Collision detection
            state.projectiles = state.projectiles.filter(projectile => {
                state.enemies.forEach(enemy => {
                    const dx = projectile.x - enemy.x;
                    const dy = projectile.y - enemy.y;
                    const distance = Math.sqrt(dx*dx + dy*dy);
                    
                    if(distance < projectile.radius + enemy.radius) {
                        enemy.health += projectile.damage;
                        if(enemy.health <= 0) {
                            state.enemies.splice(state.enemies.indexOf(enemy), 1);
                        }
                    }
                });
                return projectile.x > -50 && projectile.x < canvas.width + 50 &&
                       projectile.y > -50 && projectile.y < canvas.height + 50;
            });
        }

        // Render
        function draw() {
            ctx.fillStyle = '#87CEEB';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Draw player
            ctx.fillStyle = '#FFFFFF';
            ctx.beginPath();
            ctx.arc(state.player.x, state.player.y, state.player.radius, 0, Math.PI*2);
            ctx.fill();

            // Draw equipped petals
            state.player.equipped.forEach((petal, i) => {
                ctx.fillStyle = petal.color;
                ctx.beginPath();
                ctx.arc(
                    state.player.x + Math.cos((i * Math.PI/2)) * 35,
                    state.player.y + Math.sin((i * Math.PI/2)) * 35,
                    12, 0, Math.PI*2
                );
                ctx.fill();
            });

            // Draw projectiles
            state.projectiles.forEach(projectile => {
                ctx.fillStyle = projectile.color;
                ctx.beginPath();
                ctx.arc(projectile.x, projectile.y, projectile.radius, 0, Math.PI*2);
                ctx.fill();
            });

            // Draw petals
            state.petals.forEach(petal => {
                ctx.fillStyle = PETAL_TYPES[petal.type].color;
                ctx.beginPath();
                ctx.arc(petal.x, petal.y, 15, 0, Math.PI*2);
                ctx.fill();
            });

            // Draw enemies
            state.enemies.forEach(enemy => {
                ctx.fillStyle = '#FF4444';
                ctx.beginPath();
                ctx.arc(enemy.x, enemy.y, enemy.radius, 0, Math.PI*2);
                ctx.fill();
            });

            // UI
            UI.innerHTML = `
                Health: ${Math.round(state.player.health)}<br>
                Petals: ${state.player.equipped.length}<br>
                ${state.player.equipped.map(p => p.type).join(', ')}
            `;
        }

        // Game loop
        function gameLoop() {
            update();
            draw();
            requestAnimationFrame(gameLoop);
        }

        // Start game
        spawnPetals();
        gameLoop();
    </script>
</body>
</htmlstate.lastEnemySpawn = now;
            }

            state.enemies.forEach(enemy => {
                // Move towards player
                const angle = Math.atan2(
                    state.player.y - enemy.y,
                    state.player.x - enemy.x
                );
                enemy.x += Math.cos(angle) * enemy.speed;
                enemy.y += Math.sin(angle) * enemy.speed;

                // Collision with player
                const dx = state.player.x - enemy.x;
                const dy = state.player.y - enemy.y;
                const distance = Math.sqrt(dx*dx + dy*dy);
                
                if(distance < state.player.radius + enemy.radius) {
                    state.player.health -= 1;
                }
            });

            // Collision detection
            state.projectiles = state.projectiles.filter(projectile => {
                state.enemies.forEach(enemy => {
                    const dx = projectile.x - enemy.x;
                    const dy = projectile.y - enemy.y;
                    const distance = Math.sqrt(dx*dx + dy*dy);
                    
                    if(distance < projectile.radius + enemy.radius) {
                        enemy.health += projectile.damage;
                        if(enemy.health <= 0) {
                            state.enemies.splice(state.enemies.indexOf(enemy), 1);
                        }
                    }
                });
                return projectile.x > -50 && projectile.x < canvas.width + 50 &&
                       projectile.y > -50 && projectile.y < canvas.height + 50;
            });
        }

        // Render
        function draw() {
            ctx.fillStyle = '#87CEEB';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Draw player
            ctx.fillStyle = '#FFFFFF';
            ctx.beginPath();
            ctx.arc(state.player.x, state.player.y, state.player.radius, 0, Math.PI*2);
            ctx.fill();

            // Draw equipped petals
            state.player.equipped.forEach((petal, i) => {
                ctx.fillStyle = petal.color;
                ctx.beginPath();
                ctx.arc(
                    state.player.x + Math.cos((i * Math.PI/2)) * 35,
                    state.player.y + Math.sin((i * Math.PI/2)) * 35,
                    12, 0, Math.PI*2
                );
                ctx.fill();
            });

            // Draw projectiles
            state.projectiles.forEach(projectile => {
                ctx.fillStyle = projectile.color;
                ctx.beginPath();
                ctx.arc(projectile.x, projectile.y, projectile.radius, 0, Math.PI*2);
                ctx.fill();
            });

            // Draw petals
            state.petals.forEach(petal => {
                ctx.fillStyle = PETAL_TYPES[petal.type].color;
                ctx.beginPath();
                ctx.arc(petal.x, petal.y, 15, 0, Math.PI*2);
                ctx.fill();
            });

            // Draw enemies
            state.enemies.forEach(enemy => {
                ctx.fillStyle = '#FF4444';
                ctx.beginPath();
                ctx.arc(enemy.x, enemy.y, enemy.radius, 0, Math.PI*2);
                ctx.fill();
            });

            // UI
            UI.innerHTML = `
                Health: ${Math.round(state.player.health)}<br>
                Petals: ${state.player.equipped.length}<br>
                ${state.player.equipped.map(p => p.type).join(', ')}
            `;
        }

        // Game loop
        function gameLoop() {
            update();
            draw();
            requestAnimationFrame(gameLoop);
        }

        // Start game
        spawnPetals();
        gameLoop();
    </script>
</body>
</htmlstate.lastEnemySpawn = now;
            }

            state.enemies.forEach(enemy => {
                // Move towards player
                const angle = Math.atan2(
                    state.player.y - enemy.y,
                    state.player.x - enemy.x
                );
                enemy.x += Math.cos(angle) * enemy.speed;
                enemy.y += Math.sin(angle) * enemy.speed;

                // Collision with player
                const dx = state.player.x - enemy.x;
                const dy = state.player.y - enemy.y;
                const distance = Math.sqrt(dx*dx + dy*dy);
                
                if(distance < state.player.radius + enemy.radius) {
                    state.player.health -= 1;
                }
            });

            // Collision detection
            state.projectiles = state.projectiles.filter(projectile => {
                state.enemies.forEach(enemy => {
                    const dx = projectile.x - enemy.x;
                    const dy = projectile.y - enemy.y;
                    const distance = Math.sqrt(dx*dx + dy*dy);
                    
                    if(distance < projectile.radius + enemy.radius) {
                        enemy.health += projectile.damage;
                        if(enemy.health <= 0) {
                            state.enemies.splice(state.enemies.indexOf(enemy), 1);
                        }
                    }
                });
                return projectile.x > -50 && projectile.x < canvas.width + 50 &&
                       projectile.y > -50 && projectile.y < canvas.height + 50;
            });
        }

        // Render
        function draw() {
            ctx.fillStyle = '#87CEEB';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Draw player
            ctx.fillStyle = '#FFFFFF';
            ctx.beginPath();
            ctx.arc(state.player.x, state.player.y, state.player.radius, 0, Math.PI*2);
            ctx.fill();

            // Draw equipped petals
            state.player.equipped.forEach((petal, i) => {
                ctx.fillStyle = petal.color;
                ctx.beginPath();
                ctx.arc(
                    state.player.x + Math.cos((i * Math.PI/2)) * 35,
                    state.player.y + Math.sin((i * Math.PI/2)) * 35,
                    12, 0, Math.PI*2
                );
                ctx.fill();
            });

            // Draw projectiles
            state.projectiles.forEach(projectile => {
                ctx.fillStyle = projectile.color;
                ctx.beginPath();
                ctx.arc(projectile.x, projectile.y, projectile.radius, 0, Math.PI*2);
                ctx.fill();
            });

            // Draw petals
            state.petals.forEach(petal => {
                ctx.fillStyle = PETAL_TYPES[petal.type].color;
                ctx.beginPath();
                ctx.arc(petal.x, petal.y, 15, 0, Math.PI*2);
                ctx.fill();
            });

            // Draw enemies
            state.enemies.forEach(enemy => {
                ctx.fillStyle = '#FF4444';
                ctx.beginPath();
                ctx.arc(enemy.x, enemy.y, enemy.radius, 0, Math.PI*2);
                ctx.fill();
            });

            // UI
            UI.innerHTML = `
                Health: ${Math.round(state.player.health)}<br>
                Petals: ${state.player.equipped.length}<br>
                ${state.player.equipped.map(p => p.type).join(', ')}
            `;
        }

        // Game loop
        function gameLoop() {
            update();
            draw();
            requestAnimationFrame(gameLoop);
        }

        // Start game
        spawnPetals();
        gameLoop();
    </script>
</body>
</html
